/*
 * Assignatura 21742 - Compiladors
 * Estudis: Grau en Informàtica
 * Itinerari: Computació
 * Curs: 2022 - 2023
 */

package grammar;

import java_cup.runtime.*;
import core.*;

class Parser;
parser code {:
    Chadpp tree;

    public Chadpp getTree(){ return tree; }
:}


/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/

terminal        BEGIN, MAIN, ALPHA, CONST, RETURN, INT, BOL, TUP, VOID,
                IF, WHILE, LOOP, AND, OR, PLUS, MINUS, MULT,
                DIV, OUT, ININT, INBOL, EQUAL, REQUAL, LT, GT,
                SEMICOLON, COMMA, LPAREN, RPAREN, LKEY, RKEY, LSKEY,
                RSKEY ;

terminal        String      NUMBER;
terminal        String      ID;
terminal        String      VBOL;

non terminal    Chadpp      CHADPP;
non terminal    Main        MAINFN;
non terminal    L_Decls     DECLS;
non terminal    Decl        DECL;
non terminal    TypeVar     TYPEVAR;
non terminal    Asignation  ASIGNATION;
non terminal    Expresion   EXPRESION;
non terminal    Op          OP;
non terminal    Value       VALUE;
non terminal    Tuple       V_TUP;
non terminal    A_Tuple     A_TUP;
non terminal    CallFn      CALLF;
non terminal    L_Args      ARGS;
non terminal    L_Instrs    INSTRS;
non terminal    Instr       INSTR;
non terminal    L_FArgs     F_ARGS;
non terminal    L_FArgs     F_ARGS2;
non terminal    L_Function  FUNCTIONS;
non terminal    Function    FUNCTION;
non terminal    L_Ids       LID;

start with CHADPP;

CHADPP          ::= MAINFN:main FUNCTIONS:fun                   {: tree = new Chadpp(main, fun); :}
                ;

MAINFN          ::= MAIN LKEY DECLS:decls BEGIN INSTRS:i RKEY   {: RESULT = new Main(decls, i); :}
                |   MAIN LKEY INSTRS:i RKEY                     {: RESULT = new Main(null, i); :}
                ;


DECLS           ::= DECL:d DECLS:ld                             {: RESULT = new L_Decls(d, ld); :}
                | DECL:d                                        {: RESULT = new L_Decls(d); :}
                ;

DECL            ::= CONST TYPEVAR:type ASIGNATION:assig         {: RESULT = new Decl(true, type, assig); :}
                |   TYPEVAR:type ASIGNATION:assig               {: RESULT = new Decl(false, type, assig); :}
                ;

TYPEVAR         ::= INT                                         {: RESULT = TypeVar.INT; :}
                |   BOL                                         {: RESULT = TypeVar.BOOL; :}
                |   TUP                                         {: RESULT = TypeVar.TUP; :}
                ;

ASIGNATION      ::= LID:lid EQUAL EXPRESION:e SEMICOLON         {: RESULT = new Asignation(lid, e); :};

LID             ::= ID:id COMMA LID:lid                         {: RESULT = new L_Ids(id, lid); :}
                | ID:id                                         {: RESULT = new L_Ids(id); :}
                ;

EXPRESION       ::= VALUE:v OP:op EXPRESION:e                   {: RESULT = new Expresion(v, e, op); :}
                |   VALUE:v                                     {: RESULT = new Expresion(v); :}
                ;

OP              ::= PLUS                                        {: RESULT = Op.PLUS; :}
                |   MINUS                                       {: RESULT = Op.MINUS; :}
                |   MULT                                        {: RESULT = Op.MULT; :}
                |   DIV                                         {: RESULT = Op.DIV; :}
                |   REQUAL                                      {: RESULT = Op.REQUAL; :}
                |   LT                                          {: RESULT = Op.LT; :}
                |   GT                                          {: RESULT = Op.GT; :}
                |   AND                                         {: RESULT = Op.AND; :}
                |   OR                                          {: RESULT = Op.OR; :}
//                |   NOT
                ;

VALUE           ::= LPAREN EXPRESION:e RPAREN                   //{: RESULT = new Value(e); :}                // (E)
                |   V_TUP                                                                                   // [a,b,c]
                |   A_TUP                                                                                   // v[5]
                |   NUMBER:n                                    {: RESULT = new Value("Number", n); :}      // 1
                |   VBOL:b                                      {: RESULT = new Value("Bol", b); :}        // true
                |   CALLF:call                                  //{: RESULT = new Value(call); :}             // fn()
                |   ID:id                                       //{: RESULT = new Value("Id", id); :}         // a
                ;

V_TUP           ::= LSKEY ARGS RSKEY; // No se permite []. Al menos debe tener un elemento i.e [A]

A_TUP           ::= ID LSKEY NUMBER RSKEY;

CALLF           ::= ID LPAREN ARGS RPAREN
                |   ID LPAREN RPAREN
                |   ININT LPAREN RPAREN
                |   INBOL LPAREN RPAREN
                ;

ARGS            ::= EXPRESION COMMA ARGS
                |   EXPRESION
                ;

INSTRS          ::= INSTR INSTRS
                |
                ;

INSTR           ::= IF LPAREN EXPRESION RPAREN LKEY INSTRS RKEY
                |   WHILE LPAREN EXPRESION RPAREN LKEY INSTRS RKEY
                |   LOOP LPAREN EXPRESION COMMA EXPRESION RPAREN LKEY INSTRS RKEY
                |   RETURN EXPRESION SEMICOLON
                |   OUT LPAREN EXPRESION RPAREN SEMICOLON
                |   ASIGNATION
                |   CALLF SEMICOLON
                ;

FUNCTIONS        ::= FUNCTION FUNCTIONS
                |
                ;

FUNCTION         ::= TYPEVAR ALPHA ID LPAREN F_ARGS RPAREN LKEY DECLS BEGIN INSTRS RKEY
                |   VOID ALPHA ID LPAREN F_ARGS RPAREN LKEY DECLS BEGIN INSTRS RKEY
                |   TYPEVAR ALPHA ID LPAREN F_ARGS RPAREN LKEY INSTRS RKEY
                |   VOID ALPHA ID LPAREN F_ARGS RPAREN LKEY INSTRS RKEY
                ;

F_ARGS          ::= F_ARGS2
                |
                ;

F_ARGS2        ::= TYPEVAR ID COMMA F_ARGS
                |   TYPEVAR ID
                ;