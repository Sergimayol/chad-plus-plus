/*
 * Assignatura 21742 - Compiladors
 * Estudis: Grau en Informàtica
 * Itinerari: Computació
 * Curs: 2022 - 2023
 */

package grammar;

import core.*;

class Parser;
parser code {:
    Chadpp tree;

    public Chadpp getTree(){ return tree; }
:}


/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/

terminal        BEGIN, MAIN, ALPHA, CONST, RETURN, INT, BOL, TUP, VOID,
                IF, WHILE, LOOP, AND, OR, PLUS, MINUS, MULT,
                DIV, OUT, ININT, INBOL, EQUAL, REQUAL, LT, GT,
                SEMICOLON, COMMA, LPAREN, RPAREN, LKEY, RKEY, LSKEY,
                RSKEY ;

terminal        String      NUMBER;
terminal        String      ID;
terminal        String      VBOL;

non terminal    Chadpp      CHADPP;
non terminal    Main        MAINFN;
non terminal    L_Decls     DECLS;
non terminal    Decl        DECL;
non terminal    TypeVar     TYPEVAR;
non terminal    TypeFn      TYPEFN;
non terminal    Asignation  ASIGNATION;
non terminal    Expresion   EXPRESION;
non terminal    Op          OP;
non terminal    Value       VALUE;
non terminal    Tuple       V_TUP;
non terminal    A_Tuple     A_TUP;
non terminal    CallFn      CALLF;
non terminal    L_Args      ARGS;
non terminal    L_Instrs    INSTRS;
non terminal    L_Instrs    R_INSTRS;
non terminal    Instr       INSTR;
non terminal    Instr       R_INSTR;
non terminal    L_FArgs     F_ARGS;
non terminal    L_FArgs     F_ARGS2;
non terminal    L_Fn        FUNCTIONS;
non terminal    Function    FUNCTION;
non terminal    L_Ids       LID;

start with CHADPP;

CHADPP          ::= MAINFN:main FUNCTIONS:fun                   {: tree = new Chadpp(main, fun); :}
                ;

MAINFN          ::= MAIN LKEY DECLS:decls BEGIN INSTRS:i RKEY   {: RESULT = new Main(decls, i); :}
                |   MAIN LKEY INSTRS:i RKEY                     {: RESULT = new Main(null, i); :}
                ;


DECLS           ::= DECL:d DECLS:ld                             {: RESULT = new L_Decls(d, ld); :}
                | DECL:d                                        {: RESULT = new L_Decls(d); :}
                ;

DECL            ::= CONST TYPEVAR:type ASIGNATION:assig         {: RESULT = new Decl(true, type, assig); :}
                |   TYPEVAR:type ASIGNATION:assig               {: RESULT = new Decl(false, type, assig); :}
                ;

TYPEVAR         ::= INT                                         {: RESULT = TypeVar.INT; :}
                |   BOL                                         {: RESULT = TypeVar.BOOL; :}
                |   TUP                                         {: RESULT = TypeVar.TUP; :}
                ;

ASIGNATION      ::= LID:lid EQUAL EXPRESION:e SEMICOLON         {: RESULT = new Asignation(lid, e); :};

LID             ::= ID:id COMMA LID:lid                         {: RESULT = new L_Ids(id, lid); :}
                | ID:id                                         {: RESULT = new L_Ids(id); :}
                ;

EXPRESION       ::= VALUE:v OP:op EXPRESION:e                   {: RESULT = new Expresion(v, e, op); :}
                |   VALUE:v                                     {: RESULT = new Expresion(v); :}
                ;

OP              ::= PLUS                                        {: RESULT = Op.PLUS; :}
                |   MINUS                                       {: RESULT = Op.MINUS; :}
                |   MULT                                        {: RESULT = Op.MULT; :}
                |   DIV                                         {: RESULT = Op.DIV; :}
                |   REQUAL                                      {: RESULT = Op.REQUAL; :}
                |   LT                                          {: RESULT = Op.LT; :}
                |   GT                                          {: RESULT = Op.GT; :}
                |   AND                                         {: RESULT = Op.AND; :}
                |   OR                                          {: RESULT = Op.OR; :}
//                |   NOT
                ;

VALUE           ::= LPAREN EXPRESION:e RPAREN                   {: RESULT = new Value(e); :}                // (E)
                |   V_TUP                                                                                   // [a,b,c]
                |   A_TUP                                                                                   // v[5]
                |   NUMBER:n                                    {: RESULT = new Value("Number", n); :}      // 1
                |   VBOL:b                                      {: RESULT = new Value("Bol", b); :}        // true
                |   CALLF:call                                  {: RESULT = new Value(call); :}             // fn()
                |   ININT LPAREN RPAREN                         {: RESULT = new Value(new Input(0)); :}
                |   INBOL LPAREN RPAREN                         {: RESULT = new Value(new Input(1)); :}
                |   ID:id                                       {: RESULT = new Value("Id", id); :}         // a
                ;

V_TUP           ::= LSKEY ARGS RSKEY; // No se permite []. Al menos debe tener un elemento i.e [A]

A_TUP           ::= ID LSKEY NUMBER RSKEY;

CALLF           ::= ID:id LPAREN ARGS:args RPAREN               {: RESULT = new CallFn(new Id(id), args); :}
                |   ID:id LPAREN RPAREN                         {: RESULT = new CallFn(new Id(id)); :}
                ;

ARGS            ::= EXPRESION:e COMMA ARGS:args                 {: RESULT = new L_Args(e, args); :}
                |   EXPRESION:e                                 {: RESULT = new L_Args(e); :}
                ;

INSTRS          ::= INSTR:inst INSTRS:instrs                    {: RESULT = new L_Instrs(inst, instrs); :}
                |                                               {: :}
                ;

R_INSTRS        ::= R_INSTR:inst R_INSTRS:instrs                {: RESULT = new L_Instrs(inst, instrs); :}
                |                                               {: :}
                ;

R_INSTR         ::= INSTR:instr                                                                 {: RESULT = instr; :}
                |   RETURN EXPRESION:e SEMICOLON                                                {: RESULT = new Instr(new ReturnNode(e)); :}
                ;

INSTR           ::= IF LPAREN EXPRESION:e RPAREN LKEY INSTRS:instrs RKEY                        {: RESULT = new Instr(new IfNode(e, instrs)); :}
                |   WHILE LPAREN EXPRESION:e RPAREN LKEY INSTRS:instrs RKEY                     {: RESULT = new Instr(new WhileNode(e, instrs)); :}
                |   LOOP LPAREN EXPRESION:e1 COMMA EXPRESION:e2 RPAREN LKEY INSTRS:instrs RKEY  {: RESULT = new Instr(new LoopNode(e1, e2, instrs)); :}
                |   OUT LPAREN EXPRESION:e RPAREN SEMICOLON                                     {: RESULT = new Instr(new Output(e)); :}
                |   ININT LPAREN RPAREN SEMICOLON                                               {: RESULT = new Instr(new Input(0)); :}
                |   INBOL LPAREN RPAREN SEMICOLON                                               {: RESULT = new Instr(new Input(1)); :}
                |   ASIGNATION:a                                                                {: RESULT = new Instr(a); :}
                |   CALLF:fn SEMICOLON                                                          {: RESULT = new Instr(fn); :}
                ;

FUNCTIONS        ::= FUNCTION:fn FUNCTIONS:fns                  {: RESULT = new L_Fn(fn, fns); :}
                |                                               {: :}
                ;

FUNCTION         ::= TYPEVAR:t ALPHA ID:id LPAREN F_ARGS:args RPAREN LKEY DECLS:decls BEGIN R_INSTRS:instrs RKEY    {: RESULT = new Function(t, new Id(id), args, decls,instrs); :}
                |   TYPEVAR:t ALPHA ID:id LPAREN F_ARGS:args RPAREN LKEY R_INSTRS:instrs RKEY                       {: RESULT = new Function(t, new Id(id), args, null, instrs); :}
                |   VOID ALPHA ID:id LPAREN F_ARGS:args RPAREN LKEY DECLS:decls BEGIN INSTRS:instrs RKEY            {: RESULT = new Function(null, new Id(id), args, null, instrs); :}
                |   VOID ALPHA ID:id LPAREN F_ARGS:args RPAREN LKEY INSTRS:instrs RKEY                              {: RESULT = new Function(null, new Id(id), args, null, instrs); :}
                ;

F_ARGS          ::= F_ARGS2:args    {: RESULT = args; :}
                |                   {: :}
                ;

F_ARGS2        ::= TYPEVAR:type ID:id COMMA F_ARGS2:args    {: RESULT = new L_FArgs( new FnArg(type, new Id(id)), args); :}
                |   TYPEVAR:type ID:id                      {: RESULT = new L_FArgs( new FnArg(type, new Id(id)), null); :}
                ;